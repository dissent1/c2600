<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>aMule: src/OtherFunctions.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>src/OtherFunctions.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">// This file is part of the aMule Project.</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (c) 2003-2011 aMule Team ( admin@amule.org / http://www.amule.org )</span>
<a name="l00005"></a>00005 <span class="comment">// Copyright (c) 2002-2011 Merkur ( devs@emule-project.net / http://www.emule-project.net )</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// Any parts of this program derived from the xMule, lMule or eMule project,</span>
<a name="l00008"></a>00008 <span class="comment">// or contributed by third-party developers are copyrighted by their</span>
<a name="l00009"></a>00009 <span class="comment">// respective authors.</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l00012"></a>00012 <span class="comment">// it under the terms of the GNU General Public License as published by</span>
<a name="l00013"></a>00013 <span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00014"></a>00014 <span class="comment">// (at your option) any later version.</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00017"></a>00017 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00018"></a>00018 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00019"></a>00019 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00022"></a>00022 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l00023"></a>00023 <span class="comment">// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA</span>
<a name="l00024"></a>00024 <span class="comment">//</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#ifndef OTHERFUNCTIONS_H</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define OTHERFUNCTIONS_H</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;wx/intl.h&gt;</span>        <span class="comment">// Needed for wxLANGUAGE_ constants</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;Types.h&quot;</span>      <span class="comment">// Needed for uint16, uint32 and uint64</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;Preferences.h&quot;</span>    <span class="comment">// Needed for AllCategoryFilter enumeration</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;algorithm&gt;</span>        <span class="comment">// Needed for std::for_each // Do_not_auto_remove (mingw-gcc-3.4.5)</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">class </span><a class="code" href="classCPath.html" title="This class wraps a path/filename, serving a purpose much like wxFileName.">CPath</a>;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 
<a name="l00052"></a>00052 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
<a name="l00053"></a>00053 <span class="keywordtype">int</span> CmpAny(<span class="keyword">const</span> TYPE&amp; ArgA, <span class="keyword">const</span> TYPE&amp; ArgB)
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055     <span class="keywordflow">if</span> ( ArgA &lt; ArgB ) {
<a name="l00056"></a>00056         <span class="keywordflow">return</span> -1;
<a name="l00057"></a>00057     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ArgB &lt; ArgA ) {
<a name="l00058"></a>00058         <span class="keywordflow">return</span>  1;
<a name="l00059"></a>00059     } <span class="keywordflow">else</span> {
<a name="l00060"></a>00060         <span class="keywordflow">return</span>  0;
<a name="l00061"></a>00061     }
<a name="l00062"></a>00062 }
<a name="l00063"></a>00063 
<a name="l00065"></a>00065 <span class="keyword">inline</span> <span class="keywordtype">int</span> CmpAny(<span class="keyword">const</span> wxString&amp; ArgA, <span class="keyword">const</span> wxString&amp; ArgB)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067     <span class="keywordflow">if</span> (ArgA.IsEmpty() &amp;&amp; !ArgB.IsEmpty()) {
<a name="l00068"></a>00068         <span class="keywordflow">return</span> -1;
<a name="l00069"></a>00069     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ArgA.IsEmpty() &amp;&amp; ArgB.IsEmpty()) {
<a name="l00070"></a>00070         <span class="keywordflow">return</span> 1;
<a name="l00071"></a>00071     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ArgA.IsEmpty() &amp;&amp; ArgB.IsEmpty()) {
<a name="l00072"></a>00072         <span class="keywordflow">return</span> 0;
<a name="l00073"></a>00073     } <span class="keywordflow">else</span> {
<a name="l00074"></a>00074         <span class="keywordflow">return</span> ArgA.CmpNoCase( ArgB );
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00079"></a>00079 <span class="keyword">inline</span> <span class="keywordtype">int</span> CmpAny(<span class="keyword">const</span> wxChar* ArgA, <span class="keyword">const</span> wxChar* ArgB)
<a name="l00080"></a>00080 {
<a name="l00081"></a>00081     <span class="keywordflow">return</span> CmpAny(wxString( ArgA ), wxString( ArgB ));
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00092"></a>00092 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LIST, <span class="keyword">typename</span> ITEM&gt;
<a name="l00093"></a>00093 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EraseFirstValue( LIST&amp; list, <span class="keyword">const</span> ITEM&amp; item )
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095     <span class="keyword">typename</span> LIST::iterator it = list.begin();
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="keywordflow">for</span> (; it != list.end(); ++it) {
<a name="l00098"></a>00098         <span class="keywordflow">if</span> (*it == item) {
<a name="l00099"></a>00099             list.erase(it);
<a name="l00100"></a>00100             
<a name="l00101"></a>00101             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00102"></a>00102         }
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00106"></a>00106 }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00116"></a>00116 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LIST, <span class="keyword">typename</span> ITEM&gt;
<a name="l00117"></a>00117 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EraseValue( LIST&amp; list, <span class="keyword">const</span> ITEM&amp; item )
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119     <span class="keyword">typename</span> LIST::iterator it = list.begin();
<a name="l00120"></a>00120     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count = 0;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="keywordflow">for</span> ( ; it != list.end(); ) {
<a name="l00123"></a>00123         <span class="keywordflow">if</span> ( *it == item ) {
<a name="l00124"></a>00124             it = list.erase( it );
<a name="l00125"></a>00125             count++;
<a name="l00126"></a>00126         } <span class="keywordflow">else</span> {
<a name="l00127"></a>00127             ++it;
<a name="l00128"></a>00128         }
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordflow">return</span> count;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 
<a name="l00136"></a><a class="code" href="structSDoDelete.html">00136</a> <span class="keyword">struct </span><a class="code" href="structSDoDelete.html" title="Used by DeleteContents.">SDoDelete</a>
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138     <span class="comment">// Used for lists, vectors, deques, etc.</span>
<a name="l00139"></a>00139     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
<a name="l00140"></a>00140     <span class="keywordtype">void</span> operator()(TYPE* ptr) {
<a name="l00141"></a>00141         <span class="keyword">delete</span> ptr;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="comment">// Used for maps, hashmaps, rangemaps, etc.</span>
<a name="l00145"></a>00145     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FIRST, <span class="keyword">typename</span> SECOND&gt;
<a name="l00146"></a>00146     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> std::pair&lt;FIRST, SECOND&gt;&amp; pair) {
<a name="l00147"></a>00147         <span class="keyword">delete</span> pair.second;
<a name="l00148"></a>00148     }       
<a name="l00149"></a>00149 };
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 
<a name="l00153"></a>00153 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> STL_CONTAINER&gt;
<a name="l00154"></a>00154 <span class="keywordtype">void</span> DeleteContents(STL_CONTAINER&amp; container)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156     <span class="comment">// Ensure that the actual container wont contain dangling pointers during</span>
<a name="l00157"></a>00157     <span class="comment">// this operation, to ensure that the destructors cant access them.</span>
<a name="l00158"></a>00158     STL_CONTAINER copy;
<a name="l00159"></a>00159     
<a name="l00160"></a>00160     std::swap(copy, container);
<a name="l00161"></a>00161     std::for_each(copy.begin(), copy.end(), <a class="code" href="structSDoDelete.html" title="Used by DeleteContents.">SDoDelete</a>());
<a name="l00162"></a>00162 }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 
<a name="l00168"></a>00168 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator&gt;
<a name="l00169"></a>00169 OutputIterator STLCopy_n(InputIterator first, <span class="keywordtype">size_t</span> n, OutputIterator result)
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171     <span class="keywordflow">return</span> std::copy(first, first + n, result);
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00184"></a>00184 wxString GetMuleVersion();
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 
<a name="l00202"></a>00202 <span class="preprocessor">#define CastChild( IdOrName, type )         dynamic_cast&lt;type*&gt;( FindWindow( IdOrName ) )</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>
<a name="l00204"></a>00204 
<a name="l00214"></a>00214 <span class="preprocessor">#define CastByID( ID, parent, type )        dynamic_cast&lt;type*&gt;( wxWindow::FindWindowById( (ID), (parent) ) )</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>
<a name="l00216"></a>00216 
<a name="l00226"></a>00226 <span class="preprocessor">#define CastByName( Name, parent, type )    dynamic_cast&lt;type*&gt;( wxWindow::FindWindowByName( (Name), (parent) ) )</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// From Gnucleus project [found by Tarod]</span>
<a name="l00230"></a>00230 <span class="comment">// Base16/Base32/Base64 Encode/Decode functions</span>
<a name="l00231"></a>00231 wxString EncodeBase16(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufLen);
<a name="l00232"></a>00232 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DecodeBase16(<span class="keyword">const</span> wxString &amp;base16Buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> base16BufLen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer);
<a name="l00233"></a>00233 wxString EncodeBase32(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufLen);
<a name="l00234"></a>00234 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DecodeBase32(<span class="keyword">const</span> wxString &amp;base32Buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> base32BufLen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer);
<a name="l00235"></a>00235 wxString EncodeBase64(<span class="keyword">const</span> <span class="keywordtype">char</span>* buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufLen);
<a name="l00236"></a>00236 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DecodeBase64(<span class="keyword">const</span> wxString &amp;base64Buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> base64BufLen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">// Converts the number of bytes to human readable form.</span>
<a name="l00239"></a>00239 wxString CastItoXBytes(uint64 count);
<a name="l00240"></a>00240 <span class="comment">// Converts the number to human readable form, abbreviating when nessecary.</span>
<a name="l00241"></a>00241 wxString CastItoIShort(uint64 number);
<a name="l00242"></a>00242 <span class="comment">// Converts a number of bytes to a human readable speed value.</span>
<a name="l00243"></a>00243 wxString CastItoSpeed(uint32 bytes);
<a name="l00244"></a>00244 <span class="comment">// Converts an amount of seconds to human readable time.</span>
<a name="l00245"></a>00245 wxString CastSecondsToHM(uint32 seconds, uint16 msecs = 0);
<a name="l00246"></a>00246 <span class="comment">// Returns the amount of Bytes the provided size-type represents</span>
<a name="l00247"></a>00247 uint32 GetTypeSize(uint8 type);
<a name="l00248"></a>00248 <span class="comment">// Returns the string associated with a file-rating value.</span>
<a name="l00249"></a>00249 wxString GetRateString(uint16 rate);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="comment">// The following functions are used to identify and/or name the type of a file</span>
<a name="l00253"></a>00253 <span class="keyword">enum</span> FileType { ftAny, ftVideo, ftAudio, ftArchive, ftCDImage, ftPicture, ftText, ftProgram };
<a name="l00254"></a>00254 <span class="comment">// Examins a filename and returns the enumerated value assosiated with it, or ftAny if unknown extension</span>
<a name="l00255"></a>00255 FileType GetFiletype(<span class="keyword">const</span> <a class="code" href="classCPath.html" title="This class wraps a path/filename, serving a purpose much like wxFileName.">CPath</a>&amp; filename);
<a name="l00256"></a>00256 <span class="comment">// Returns the description of a filetype: Movies, Audio, Pictures and so on...</span>
<a name="l00257"></a>00257 wxString GetFiletypeDesc(FileType type, <span class="keywordtype">bool</span> translated = <span class="keyword">true</span>);
<a name="l00258"></a>00258 <span class="comment">// Shorthand for GetFiletypeDesc(GetFiletype(filename))</span>
<a name="l00259"></a>00259 wxString GetFiletypeByName(<span class="keyword">const</span> <a class="code" href="classCPath.html" title="This class wraps a path/filename, serving a purpose much like wxFileName.">CPath</a>&amp; filename, <span class="keywordtype">bool</span> translated = <span class="keyword">true</span>);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="comment">// Returns the name associated with a category value.</span>
<a name="l00263"></a>00263 wxString GetCatTitle(AllCategoryFilter cat);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment">/* Other */</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 
<a name="l00269"></a>00269 <span class="preprocessor">#define itemsof(x) (sizeof(x)/sizeof(x[0]))</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span>
<a name="l00271"></a>00271 
<a name="l00273"></a>00273 <span class="comment">// ED2K File Type</span>
<a name="l00274"></a>00274 <span class="comment">//</span>
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="keyword">enum</span> EED2KFileType
<a name="l00277"></a>00277 {
<a name="l00278"></a>00278     ED2KFT_ANY,
<a name="l00279"></a>00279     ED2KFT_AUDIO,
<a name="l00280"></a>00280     ED2KFT_VIDEO,
<a name="l00281"></a>00281     ED2KFT_IMAGE,
<a name="l00282"></a>00282     ED2KFT_PROGRAM,
<a name="l00283"></a>00283     ED2KFT_DOCUMENT,
<a name="l00284"></a>00284     ED2KFT_ARCHIVE,
<a name="l00285"></a>00285     ED2KFT_CDIMAGE
<a name="l00286"></a>00286 };
<a name="l00287"></a>00287 
<a name="l00288"></a><a class="code" href="classEED2KFileTypeClass.html">00288</a> <span class="keyword">class </span><a class="code" href="classEED2KFileTypeClass.html">EED2KFileTypeClass</a>
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290 <span class="keyword">public</span>:
<a name="l00291"></a>00291     <a class="code" href="classEED2KFileTypeClass.html">EED2KFileTypeClass</a>()
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293         s_t = ED2KFT_ANY;
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295     <a class="code" href="classEED2KFileTypeClass.html">EED2KFileTypeClass</a>(EED2KFileType t)
<a name="l00296"></a>00296     {
<a name="l00297"></a>00297         s_t = t;
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299     EED2KFileType GetType()<span class="keyword"> const</span>
<a name="l00300"></a>00300 <span class="keyword">    </span>{
<a name="l00301"></a>00301         <span class="keywordflow">return</span> s_t;
<a name="l00302"></a>00302     }
<a name="l00303"></a>00303     
<a name="l00304"></a>00304 <span class="keyword">private</span>:
<a name="l00305"></a>00305     EED2KFileType s_t;
<a name="l00306"></a>00306 };
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 EED2KFileType GetED2KFileTypeID(<span class="keyword">const</span> <a class="code" href="classCPath.html" title="This class wraps a path/filename, serving a purpose much like wxFileName.">CPath</a>&amp; fileName);
<a name="l00309"></a>00309 wxString GetED2KFileTypeSearchTerm(EED2KFileType iFileID);
<a name="l00310"></a>00310 wxString GetFileTypeByName(<span class="keyword">const</span> <a class="code" href="classCPath.html" title="This class wraps a path/filename, serving a purpose much like wxFileName.">CPath</a>&amp; fileName);
<a name="l00311"></a>00311 EED2KFileType GetED2KFileTypeSearchID(EED2KFileType iFileID);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">// md4cmp -- replacement for memcmp(hash1,hash2,16)</span>
<a name="l00315"></a>00315 <span class="comment">// Like &apos;memcmp&apos; this function returns 0, if hash1==hash2, and !0, if hash1!=hash2.</span>
<a name="l00316"></a>00316 <span class="comment">// NOTE: Do *NOT* use that function for determining if hash1&lt;hash2 or hash1&gt;hash2.</span>
<a name="l00317"></a>00317 <span class="keyword">inline</span> <span class="keywordtype">int</span> md4cmp(<span class="keyword">const</span> <span class="keywordtype">void</span>* hash1, <span class="keyword">const</span> <span class="keywordtype">void</span>* hash2)
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319     <span class="keywordflow">return</span> memcmp(hash1, hash2, 16);
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">// md4clr -- replacement for memset(hash,0,16)</span>
<a name="l00324"></a>00324 <span class="keyword">inline</span> <span class="keywordtype">void</span> md4clr(<span class="keywordtype">void</span>* hash)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     memset(hash, 0, 16);
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">// md4cpy -- replacement for memcpy(dst,src,16)</span>
<a name="l00331"></a>00331 <span class="keyword">inline</span> <span class="keywordtype">void</span> md4cpy(<span class="keywordtype">void</span>* dst, <span class="keyword">const</span> <span class="keywordtype">void</span>* src)
<a name="l00332"></a>00332 {
<a name="l00333"></a>00333     memcpy(dst, src, 16);
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="comment">// DumpMem ... Dumps mem ;)</span>
<a name="l00338"></a>00338 wxString DumpMemToStr(<span class="keyword">const</span> <span class="keywordtype">void</span> *buff, <span class="keywordtype">int</span> n, <span class="keyword">const</span> wxString&amp; msg = wxEmptyString, <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>);
<a name="l00339"></a>00339 <span class="keywordtype">void</span> DumpMem(<span class="keyword">const</span> <span class="keywordtype">void</span> *buff, <span class="keywordtype">int</span> n, <span class="keyword">const</span> wxString&amp; msg = wxEmptyString, <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>);
<a name="l00340"></a>00340 <span class="keywordtype">void</span> DumpMem_DW(<span class="keyword">const</span> uint32 *ptr, <span class="keywordtype">int</span> count);
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="comment">// Returns special source ID for GUI.</span>
<a name="l00343"></a>00343 <span class="comment">// It&apos;s actually IP&lt;&lt;16+Port</span>
<a name="l00344"></a>00344 <span class="preprocessor">#define GUI_ID(x,y) (uint64)((((uint64)x)&lt;&lt;16) + (uint64)y)</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span><span class="comment">// And so...</span>
<a name="l00346"></a>00346 <span class="preprocessor">#define PORT_FROM_GUI_ID(x) (x &amp; 0xFFFF)</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span><span class="preprocessor">#define IP_FROM_GUI_ID(x) (x &gt;&gt; 16)</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="keyword">inline</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> make_full_ed2k_version(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c) {
<a name="l00352"></a>00352     <span class="keywordflow">return</span> ((a &lt;&lt; 17) | (b &lt;&lt; 10) | (c &lt;&lt; 7));
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 wxString GetConfigDir(<span class="keyword">const</span> wxString &amp;configFile = wxT(<span class="stringliteral">&quot;amule.conf&quot;</span>));
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="preprocessor">#if !wxCHECK_VERSION(2, 9, 0)</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span><span class="keyword">enum</span> {
<a name="l00360"></a>00360     wxLANGUAGE_ASTURIAN = wxLANGUAGE_USER_DEFINED + 1
<a name="l00361"></a>00361 };
<a name="l00362"></a>00362 <span class="preprocessor">#endif</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>
<a name="l00367"></a>00367 <span class="keywordtype">void</span> InitCustomLanguages();
<a name="l00368"></a>00368 
<a name="l00372"></a>00372 <span class="keywordtype">void</span> InitLocale(wxLocale&amp; locale, <span class="keywordtype">int</span> language);
<a name="l00373"></a>00373 
<a name="l00377"></a>00377 <span class="keywordtype">int</span> StrLang2wx(<span class="keyword">const</span> wxString&amp; language);
<a name="l00378"></a>00378 
<a name="l00382"></a>00382 wxString wxLang2Str(<span class="keyword">const</span> <span class="keywordtype">int</span> lang);
<a name="l00383"></a>00383 
<a name="l00387"></a>00387 wxString GetPassword();
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="preprocessor">#if wxUSE_THREADS</span>
<a name="l00391"></a>00391 <span class="preprocessor"></span>
<a name="l00392"></a>00392 <span class="preprocessor">#include &lt;wx/thread.h&gt;</span>
<a name="l00393"></a>00393 
<a name="l00413"></a>00413 <span class="keyword">class </span>CMutexUnlocker
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415 <span class="keyword">public</span>:
<a name="l00416"></a>00416     <span class="comment">// unlock the mutex in the ctor</span>
<a name="l00417"></a>00417     CMutexUnlocker(wxMutex&amp; mutex)
<a name="l00418"></a>00418         : m_isOk(false), m_mutex(mutex)
<a name="l00419"></a>00419         { m_isOk = ( m_mutex.Unlock() == wxMUTEX_NO_ERROR ); }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="comment">// returns true if mutex was successfully unlocked in ctor</span>
<a name="l00422"></a>00422     <span class="keywordtype">bool</span> IsOk()<span class="keyword"> const</span>
<a name="l00423"></a>00423 <span class="keyword">        </span>{ <span class="keywordflow">return</span> m_isOk; }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="comment">// lock the mutex in dtor</span>
<a name="l00426"></a>00426     ~CMutexUnlocker()
<a name="l00427"></a>00427         { <span class="keywordflow">if</span> ( IsOk() ) m_mutex.Lock(); }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="keyword">private</span>:
<a name="l00430"></a>00430     <span class="comment">// no assignment operator nor copy ctor</span>
<a name="l00431"></a>00431     CMutexUnlocker(<span class="keyword">const</span> CMutexUnlocker&amp;);
<a name="l00432"></a>00432     CMutexUnlocker&amp; operator=(<span class="keyword">const</span> CMutexUnlocker&amp;);
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     <span class="keywordtype">bool</span>     m_isOk;
<a name="l00435"></a>00435     wxMutex&amp; m_mutex;
<a name="l00436"></a>00436 };
<a name="l00437"></a>00437 <span class="preprocessor">#endif </span><span class="comment">/* wxUSE_THREADS */</span>
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="preprocessor">#endif // OTHERFUNCTIONS_H</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="comment">// File_checked_for_headers</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 4 Dec 2014 for aMule by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
